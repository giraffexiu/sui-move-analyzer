// Copyright (c) The Diem Core Contributors
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

#[macro_use(sp)]
extern crate move_ir_types;

#[macro_export]
macro_rules! impl_convert_loc {
    ($struct_name : ident) => {
        impl ConvertLoc for $struct_name {
            fn convert_file_hash_filepath(&self, hash: &FileHash) -> Option<PathBuf> {
                self.hash_file
                    .as_ref()
                    .borrow()
                    .get_path(hash)
                    .map(|x| x.clone())
            }
            fn convert_loc_range(&self, loc: &Loc) -> Option<FileRange> {
                self.convert_file_hash_filepath(&loc.file_hash())
                    .map(|file| {
                        self.file_line_mapping.as_ref().borrow().translate(
                            &file,
                            loc.start(),
                            loc.end(),
                        )
                    })
                    .flatten()
            }
        }
    };
}

pub mod code_lens;
pub mod completion;
pub mod context;
pub mod diagnostics;
pub mod goto_definition;
pub mod hover;
pub mod inlay_hints;
pub mod item;
pub mod project;
pub mod project_context;
pub mod project_visitor;
pub mod references;
pub mod scope;
pub mod symbols;
pub mod types;
pub mod utils;
// pub mod vfs;
pub mod linter;
pub mod move_generate_spec;
pub mod move_generate_spec_chen;
pub mod move_generate_spec_file;
pub mod move_generate_spec_sel;
pub mod snap_cache;
pub mod sui_move_analyzer_beta_2024;

use move_package::source_package::parsed_manifest::{
    Dependencies, Dependency, DependencyKind, GitInfo, InternalDependency,
};
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;
use std::fmt;
use std::str::FromStr;

pub const SYSTEM_GIT_REPO: &str = "https://github.com/MystenLabs/sui.git";

#[derive(
    Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize,
)]
pub struct ProtocolVersion(u64);

impl ProtocolVersion {
    pub fn new(version: u64) -> Self {
        Self(version)
    }
    pub fn value(&self) -> u64 {
        self.0
    }
    pub const MAX: Self = Self(u64::MAX);
}

impl fmt::Display for ProtocolVersion {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl FromStr for ProtocolVersion {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Self(s.parse()?))
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SystemPackagesVersion {
    pub git_revision: String,
    pub packages: Vec<SystemPackage>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SystemPackage {
    pub package_name: String,
    pub repo_path: String,
    pub id: String,
}

/// Create a set of [Dependencies] from a [SystemPackagesVersion]; the dependencies are override git
/// dependencies to the specific revision given by the [SystemPackagesVersion]
///
/// Skips "Deepbook" dependency.
pub fn implicit_deps() -> Dependencies {
    let deps_to_skip = ["DeepBook".to_string()];
    let packages = latest_system_packages();
    packages
        .packages
        .iter()
        .filter(|package| !deps_to_skip.contains(&package.package_name))
        .map(|package| {
            (
                package.package_name.clone().into(),
                Dependency::Internal(InternalDependency {
                    kind: DependencyKind::Git(GitInfo {
                        git_url: SYSTEM_GIT_REPO.into(),
                        git_rev: packages.git_revision.clone().into(),
                        subdir: package.repo_path.clone().into(),
                    }),
                    subst: None,
                    digest: None,
                    dep_override: true,
                }),
            )
        })
        .collect()
}

fn latest_system_packages() -> SystemPackagesVersion {
    // Static mapping from protocol versions to the metadata for the system packages
    // Generated by [generate_system_packages_version_table] in build.rs
    let version_table: BTreeMap<ProtocolVersion, SystemPackagesVersion> =
        BTreeMap::from(include!(env!("SUI_SYS_PKG_TABLE")));
    version_table
        .last_key_value()
        .expect("known system package version table should be nonempty")
        .1
        .clone()
}
